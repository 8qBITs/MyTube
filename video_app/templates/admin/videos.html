{% extends "admin/base_admin.html" %}
{% block title %}Videos - Admin - MyTube{% endblock %}

{% block admin_content %}

<style>
  /* Overlay for bulk AI processing AND thumbnail regeneration */
  .ai-overlay {
    position: fixed;
    inset: 0;
    z-index: 1050;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .ai-overlay-backdrop {
    position: absolute;
    inset: 0;
    background: rgba(0, 0, 0, 0.45);
  }

  .ai-overlay-card {
    position: relative;
    z-index: 1;
    width: 100%;
    max-width: 420px;
    background: #ffffff;
    border-radius: 0.75rem;
    box-shadow: 0 0.75rem 1.25rem rgba(0, 0, 0, 0.25);
    padding: 1.5rem 1.5rem 1.25rem;
  }

  .ai-progress-wrapper {
    display: flex;
    align-items: center;
    gap: 1rem;
  }

  .ai-progress-circle-wrap {
    width: 90px;
    height: 90px;
    position: relative;
  }

  .ai-progress-circle-bg {
    stroke: #e9ecef;
    stroke-width: 8;
    fill: none;
  }

  .ai-progress-circle {
    stroke: #0d6efd;
    stroke-width: 8;
    fill: none;
    stroke-linecap: round;
    transform-origin: 50% 50%;
    transform: rotate(-90deg);
    stroke-dasharray: 100;
    stroke-dashoffset: 100;
    transition: stroke-dashoffset 0.2s ease-out;
  }

  .ai-progress-percent {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 600;
    font-size: 0.9rem;
  }

  .ai-overlay-title {
    font-size: 1.05rem;
    font-weight: 600;
    margin-bottom: 0.25rem;
  }

  .ai-overlay-subtitle {
    font-size: 0.85rem;
    color: #6c757d;
    margin-bottom: 0.75rem;
  }

  .ai-overlay-current {
    font-size: 0.85rem;
    max-height: 4rem;
    overflow: hidden;
  }
</style>

<div class="d-flex align-items-center mb-3">
  <h2 class="mb-0">Videos</h2>
</div>

<div class="card mb-3">
  <div class="card-body">
    <div class="row g-2 align-items-center">
      <div class="col-md-5">
        <label for="searchInput" class="form-label mb-1">Search by title or filename</label>
        <input type="text" id="searchInput" class="form-control form-control-sm"
               placeholder="Type to filter…">
      </div>
      <div class="col-md-2">
        <label for="rowsPerPage" class="form-label mb-1">Rows per page</label>
        <select id="rowsPerPage" class="form-select form-select-sm">
          <option value="10" selected>10</option>
          <option value="25">25</option>
          <option value="50">50</option>
          <option value="100">100</option>
        </select>
      </div>
      <div class="col-md-3 text-md-end">
        <small class="text-muted">
          Total: {{ videos|length }} video{{ videos|length != 1 and 's' or '' }}
        </small>
      </div>
      <div class="col-md-2">
        <!-- Bulk buttons: AI + Thumbnails -->
        <div class="d-grid gap-2">
          <button type="button"
                  id="aiBulkBtn"
                  class="btn btn-sm btn-outline-primary">
            <i class="bi bi-stars me-1"></i>
            AI fill missing
          </button>
          <button type="button"
                  id="thumbBulkBtn"
                  class="btn btn-sm btn-outline-secondary">
            <i class="bi bi-image me-1"></i>
            Regenerate thumbnails
          </button>
        </div>
      </div>
    </div>
  </div>
</div>

<div class="card">
  <div class="table-responsive">
    <table class="table align-middle mb-0" id="videosTable">
      <thead class="table-light">
        <tr>
          <th style="width: 60px;">ID</th>
          <th>Title</th>
          <th>Filename</th>
          <th style="width: 150px;">Uploaded</th>
          <th style="width: 90px;">Views</th>
          <th style="width: 280px;" class="text-end">Actions</th>
        </tr>
      </thead>
      <tbody id="videoTableBody">
        {% for video in videos %}
        {# determine if this video "needs AI": description empty AND title looks like a filename/placeholder #}
        {% set fn_parts = video.filename.split('.') %}
        {% if fn_parts|length > 1 %}
          {% set fn_stem = fn_parts[:-1] | join('.') %}
        {% else %}
          {% set fn_stem = video.filename %}
        {% endif %}
        {% set title_trim = (video.title or '') | trim %}
        {% set needs_ai = (not video.description or not video.description|trim) and (title_trim == '' or title_trim == fn_stem or title_trim|lower == 'untitled') %}

        <tr
          data-video-id="{{ video.id }}"
          data-ai-url="{{ url_for('admin.ai_video_metadata', video_id=video.id) }}"
          data-thumb-url="{{ url_for('admin.regenerate_thumbnail', video_id=video.id) }}"
          data-needs-ai="{{ 1 if needs_ai else 0 }}"
        >
          <td>{{ video.id }}</td>
          <td>
            <div class="fw-semibold text-truncate" style="max-width: 260px;">
              {{ video.title }}
            </div>
          </td>
          <td>
            <span class="text-muted small text-truncate d-inline-block" style="max-width: 260px;">
              {{ video.filename }}
            </span>
          </td>
          <td>
            {{ video.uploaded_at.strftime('%Y-%m-%d %H:%M') if video.uploaded_at else '' }}
          </td>
          <td>
            {{ video.view_count or 0 }}
          </td>
          <td class="text-end">
            <form method="post"
                  action="{{ url_for('admin.ai_video_metadata', video_id=video.id) }}"
                  class="d-inline">
              <button type="submit"
                      class="btn btn-sm btn-outline-primary mb-1">
                <i class="bi bi-stars me-1"></i>
                AI title &amp; description
              </button>
            </form>

            <a href="{{ url_for('admin.edit_video', video_id=video.id) }}"
               class="btn btn-sm btn-outline-secondary mb-1">
              Edit
            </a>

            <a href="{{ url_for('main.video_detail', video_id=video.id) }}"
               class="btn btn-sm btn-outline-info mb-1" target="_blank">
              View
            </a>

            <form method="post"
                  action="{{ url_for('admin.delete_video', video_id=video.id) }}"
                  class="d-inline"
                  onsubmit="return confirm('Delete this video and its file?');">
              <button type="submit"
                      class="btn btn-sm btn-outline-danger mb-1">
                Delete
              </button>
            </form>
          </td>
        </tr>
        {% endfor %}
      </tbody>
    </table>
  </div>

  <div class="card-footer d-flex justify-content-between align-items-center">
    <div>
      <small class="text-muted">
        Showing <span id="visibleCount"></span> of {{ videos|length }}
      </small>
    </div>
    <nav>
      <ul class="pagination pagination-sm mb-0" id="pagination"></ul>
    </nav>
  </div>
</div>

<!-- AI BULK PROGRESS OVERLAY -->
<div id="aiOverlay" class="ai-overlay d-none">
  <div class="ai-overlay-backdrop"></div>
  <div class="ai-overlay-card ai-overlay-card-ai">
    <div class="ai-overlay-title">Applying AI titles &amp; descriptions…</div>
    <div class="ai-overlay-subtitle">
      This may take a while if you have many videos. We won’t overwrite existing metadata.
    </div>
    <div class="ai-progress-wrapper mb-3">
      <div class="ai-progress-circle-wrap">
        <svg viewBox="0 0 80 80">
          <circle class="ai-progress-circle-bg" cx="40" cy="40" r="36"></circle>
          <circle class="ai-progress-circle" id="aiProgressCircle" cx="40" cy="40" r="36"></circle>
        </svg>
        <div class="ai-progress-percent" id="aiProgressPercent">0%</div>
      </div>
      <div class="flex-grow-1">
        <div class="small mb-1">
          <span id="aiProgressCounter">0 / 0</span> processed
        </div>
        <div class="ai-overlay-current text-muted" id="aiProgressCurrent">
          Waiting to start…
        </div>
      </div>
    </div>
    <div class="d-flex justify-content-end">
      <button type="button" class="btn btn-sm btn-outline-secondary" id="aiCancelBtn">
        Cancel
      </button>
    </div>
  </div>
</div>

<!-- THUMBNAIL BULK PROGRESS OVERLAY -->
<div id="thumbOverlay" class="ai-overlay d-none">
  <div class="ai-overlay-backdrop"></div>
  <div class="ai-overlay-card ai-overlay-card-thumb">
    <div class="ai-overlay-title">Regenerating thumbnails…</div>
    <div class="ai-overlay-subtitle">
      We’ll recreate thumbnails for all videos. This can take time for large libraries.
    </div>
    <div class="ai-progress-wrapper mb-3">
      <div class="ai-progress-circle-wrap">
        <svg viewBox="0 0 80 80">
          <circle class="ai-progress-circle-bg" cx="40" cy="40" r="36"></circle>
          <circle class="ai-progress-circle" id="thumbProgressCircle" cx="40" cy="40" r="36"></circle>
        </svg>
        <div class="ai-progress-percent" id="thumbProgressPercent">0%</div>
      </div>
      <div class="flex-grow-1">
        <div class="small mb-1">
          <span id="thumbProgressCounter">0 / 0</span> processed
        </div>
        <div class="ai-overlay-current text-muted" id="thumbProgressCurrent">
          Waiting to start…
        </div>
      </div>
    </div>
    <div class="d-flex justify-content-end">
      <button type="button" class="btn btn-sm btn-outline-secondary" id="thumbCancelBtn">
        Cancel
      </button>
    </div>
  </div>
</div>

<script>
document.addEventListener("DOMContentLoaded", function () {
  const tableBody = document.getElementById("videoTableBody");
  const rows = Array.from(tableBody.querySelectorAll("tr"));
  const rowsPerPageSelect = document.getElementById("rowsPerPage");
  const pagination = document.getElementById("pagination");
  const searchInput = document.getElementById("searchInput");
  const visibleCount = document.getElementById("visibleCount");

  let currentPage = 1;
  let filteredRows = rows.slice();

  function applyFilter() {
    const q = searchInput.value.toLowerCase().trim();
    filteredRows = rows.filter(row => {
      const title = row.children[1].innerText.toLowerCase();
      const filename = row.children[2].innerText.toLowerCase();
      return !q || title.includes(q) || filename.includes(q);
    });
    currentPage = 1;
    render();
  }

  function render() {
    const perPage = parseInt(rowsPerPageSelect.value, 10) || 10;
    const total = filteredRows.length;
    const totalPages = Math.max(1, Math.ceil(total / perPage));

    if (currentPage > totalPages) currentPage = totalPages;
    const start = (currentPage - 1) * perPage;
    const end = start + perPage;

    rows.forEach(r => r.style.display = "none");
    filteredRows.slice(start, end).forEach(r => r.style.display = "");

    if (visibleCount) {
      visibleCount.textContent = Math.min(end, total);
    }

    pagination.innerHTML = "";

    function addPage(label, page, disabled, active) {
      const li = document.createElement("li");
      li.className = "page-item" +
        (disabled ? " disabled" : "") +
        (active ? " active" : "");
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "page-link";
      btn.textContent = label;
      if (!disabled) {
        btn.addEventListener("click", function () {
          currentPage = page;
          render();
        });
      }
      li.appendChild(btn);
      pagination.appendChild(li);
    }

    addPage("«", 1, currentPage === 1, false);
    addPage("‹", currentPage - 1, currentPage === 1, false);

    for (let p = 1; p <= totalPages; p++) {
      if (p === 1 || p === totalPages || Math.abs(p - currentPage) <= 2) {
        addPage(String(p), p, false, p === currentPage);
      }
    }

    addPage("›", currentPage + 1, currentPage === totalPages, false);
    addPage("»", totalPages, currentPage === totalPages, false);
  }

  rowsPerPageSelect.addEventListener("change", render);
  searchInput.addEventListener("input", applyFilter);

  applyFilter();

  // --------- BULK AI FEATURE ---------
  const aiBulkBtn = document.getElementById("aiBulkBtn");
  const aiOverlay = document.getElementById("aiOverlay");
  const aiProgressCircle = document.getElementById("aiProgressCircle");
  const aiProgressPercent = document.getElementById("aiProgressPercent");
  const aiProgressCounter = document.getElementById("aiProgressCounter");
  const aiProgressCurrent = document.getElementById("aiProgressCurrent");
  const aiCancelBtn = document.getElementById("aiCancelBtn");

  let aiCancelRequested = false;

  function setOverlayVisible(overlayEl, visible) {
    if (!overlayEl) return;
    if (visible) {
      overlayEl.classList.remove("d-none");
    } else {
      overlayEl.classList.add("d-none");
    }
  }

  function setProgress(circleEl, percentEl, counterEl, currentEl, completed, total, label) {
    if (!circleEl || !percentEl || !counterEl) return;
    const pct = total > 0 ? (completed / total) * 100 : 0;
    const clamped = Math.max(0, Math.min(100, pct));
    const offset = 100 - clamped; // stroke-dasharray is 100
    circleEl.style.strokeDashoffset = offset;
    percentEl.textContent = `${Math.round(clamped)}%`;
    counterEl.textContent = `${completed} / ${total}`;
    if (currentEl) {
      currentEl.textContent = label || "";
    }
  }

  if (aiCancelBtn) {
    aiCancelBtn.addEventListener("click", function () {
      aiCancelRequested = true;
    });
  }

  if (aiBulkBtn) {
    aiBulkBtn.addEventListener("click", async function () {
      // Collect rows that "need AI"
      const candidates = rows.filter(r => r.dataset.needsAi === "1");
      const total = candidates.length;

      if (!total) {
        alert("No videos detected that need AI-generated metadata (empty description + placeholder title).");
        return;
      }

      aiCancelRequested = false;
      setOverlayVisible(aiOverlay, true);
      setProgress(aiProgressCircle, aiProgressPercent, aiProgressCounter, aiProgressCurrent, 0, total, "Preparing…");

      let completed = 0;

      for (const row of candidates) {
        if (aiCancelRequested) {
          setProgress(aiProgressCircle, aiProgressPercent, aiProgressCounter, aiProgressCurrent, completed, total, "Cancelled by user.");
          break;
        }

        const videoId = row.dataset.videoId;
        const aiUrl = row.dataset.aiUrl;
        const filename = row.children[2].innerText.trim();
        const title = row.children[1].innerText.trim();
        const label = title || filename || `Video #${videoId}`;
        setProgress(aiProgressCircle, aiProgressPercent, aiProgressCounter, aiProgressCurrent, completed, total, `Processing: ${label}`);

        try {
          const formData = new FormData();
          await fetch(aiUrl, {
            method: "POST",
            body: formData,
            credentials: "same-origin",
          });
          row.dataset.needsAi = "0";
          completed += 1;
          setProgress(aiProgressCircle, aiProgressPercent, aiProgressCounter, aiProgressCurrent, completed, total, `Processed: ${label}`);
        } catch (err) {
          console.error("AI metadata error for video", videoId, err);
          completed += 1; // still advance to avoid infinite loop
          setProgress(aiProgressCircle, aiProgressPercent, aiProgressCounter, aiProgressCurrent, completed, total, `Error on: ${label}`);
        }
      }

      setTimeout(function () {
        setOverlayVisible(aiOverlay, false);
        window.location.reload();
      }, 600);
    });
  }

  // --------- BULK THUMBNAIL REGEN FEATURE ---------
  const thumbBulkBtn = document.getElementById("thumbBulkBtn");
  const thumbOverlay = document.getElementById("thumbOverlay");
  const thumbProgressCircle = document.getElementById("thumbProgressCircle");
  const thumbProgressPercent = document.getElementById("thumbProgressPercent");
  const thumbProgressCounter = document.getElementById("thumbProgressCounter");
  const thumbProgressCurrent = document.getElementById("thumbProgressCurrent");
  const thumbCancelBtn = document.getElementById("thumbCancelBtn");

  let thumbCancelRequested = false;

  if (thumbCancelBtn) {
    thumbCancelBtn.addEventListener("click", function () {
      thumbCancelRequested = true;
    });
  }

  if (thumbBulkBtn) {
    thumbBulkBtn.addEventListener("click", async function () {
      // Regenerate thumbnails for ALL videos in the table
      const candidates = rows.slice();
      const total = candidates.length;

      if (!total) {
        alert("No videos found to regenerate thumbnails for.");
        return;
      }

      thumbCancelRequested = false;
      setOverlayVisible(thumbOverlay, true);
      setProgress(thumbProgressCircle, thumbProgressPercent, thumbProgressCounter, thumbProgressCurrent, 0, total, "Preparing…");

      let completed = 0;

      for (const row of candidates) {
        if (thumbCancelRequested) {
          setProgress(thumbProgressCircle, thumbProgressPercent, thumbProgressCounter, thumbProgressCurrent, completed, total, "Cancelled by user.");
          break;
        }

        const videoId = row.dataset.videoId;
        const thumbUrl = row.dataset.thumbUrl;
        const filename = row.children[2].innerText.trim();
        const title = row.children[1].innerText.trim();
        const label = title || filename || `Video #${videoId}`;
        setProgress(thumbProgressCircle, thumbProgressPercent, thumbProgressCounter, thumbProgressCurrent, completed, total, `Processing: ${label}`);

        try {
          const resp = await fetch(thumbUrl, {
            method: "POST",
            credentials: "same-origin",
          });

          let ok = false;
          try {
            const data = await resp.json();
            ok = resp.ok && data && data.success;
            if (!ok) {
              console.error("Thumbnail regen error for video", videoId, data);
            }
          } catch (jsonErr) {
            console.error("Thumbnail regen JSON parse error for video", videoId, jsonErr);
          }

          completed += 1;
          if (ok) {
            setProgress(thumbProgressCircle, thumbProgressPercent, thumbProgressCounter, thumbProgressCurrent, completed, total, `Processed: ${label}`);
          } else {
            setProgress(thumbProgressCircle, thumbProgressPercent, thumbProgressCounter, thumbProgressCurrent, completed, total, `Error on: ${label}`);
          }
        } catch (err) {
          console.error("Thumbnail regen error for video", videoId, err);
          completed += 1;
          setProgress(thumbProgressCircle, thumbProgressPercent, thumbProgressCounter, thumbProgressCurrent, completed, total, `Error on: ${label}`);
        }
      }

      setTimeout(function () {
        setOverlayVisible(thumbOverlay, false);
        // reload page to ensure any cached thumbnails / data attributes are fresh
        window.location.reload();
      }, 600);
    });
  }
});
</script>
{% endblock %}
